# 协程同步

由于协程是异步执行的方式，直接开启协程的话。当main协程退出之后，子协程也会被随着结束。默认的情况，无法实现子协程执行完之后，main协程才执行结束。

## 协程同步方式一，使用`for循环`方式实现同步。

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	count := 0
	go func() {
		time.Sleep(time.Second * 2)
		count += 1
	}()

	go func() {
		time.Sleep(time.Second * 4)
		count += 1
	}()

	go func() {
		time.Sleep(time.Second * 6)
		count += 1
	}()

	for {
		if count == 3 {
			break
		}
	}
	fmt.Println(count) // 3
}
```

## 协程同步方式二，使用`sync.WaitGroup`包实现。该包底层，实则也是在使用`for循环`实现。

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var s sync.WaitGroup
	s.Add(3)
	count := 0
	go func() {
		time.Sleep(time.Second * 2)
		count += 1
		s.Done()
	}()

	go func() {
		time.Sleep(time.Second * 4)
		count += 1
		s.Done()
	}()

	go func() {
		time.Sleep(time.Second * 6)
		count += 1
		s.Done()
	}()
	s.Wait()
	fmt.Println(count) // 3
}
```

## 协程同步方式三，使用`channel`阻塞特性来实现。

使用`channel`
在无缓冲区的情况下，只有读端和写端都准备好的情况下，才不会发生阻塞。换句话说，当读端去读数据时，如果写端没有往`channel`
中写入数据，此时整个过程是阻塞状态中。

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch := make(chan int)
	count := 0
	go func(chan int) {
		time.Sleep(time.Second * 4)
		count += 1
		ch <- 1
	}(ch)

	<-ch
	fmt.Println(count) // 1
}
```
